* {
  box-sizing: border-box;
}

body {

}

form {
  position: relative;
  margin: 1rem auto;
  background-color: #fff;
  border: 1px solid #9e9e9e;
  border-radius: 2px;
  box-shadow: 0 2px 5px 0 rgba(0,0,0,0.16),0 2px 10px 0 rgba(0,0,0,0.12);
  padding: 1.5rem 3rem 2rem 3rem;
  width: 500px;
}

form .form-header {
  /*border: 1px solid black;*/
  text-align: center;
  padding: 0 0.5rem 0.25rem 0.5rem;
  margin: 0 0 2rem 0;
  border-bottom: 1px solid #9e9e9e;
}

form .form-header figure {
  margin: 0;
}

form .form-header img {
  /* better to specify height for layout */
  max-height: 90px;
  max-width: 380px;
}

form .form-header figcaption {
  font-size: 1.25em;
}

/*form .form-header {
  padding: 0.25rem 0.5rem 0.25rem 0.5rem;
  margin: 0.5rem 0 2rem 0;
  border: 1px solid #9e9e9e;
  border-radius: 2px;
  box-shadow: inset 0px 0px 4px #9e9e9e;
}*/

/* these sets of additional rules creates a colored header that spans
   the full width of the form with white text and link color */
/*form .form-header a {
  color: #fff;
}
form .form-header {
  border-top-left-radius: 1px;
  border-top-right-radius: 1px;
  width: 498px;
  position: relative;
  top: -2rem;
  left: -3rem;
  padding: 1rem 1rem;
  margin: 1rem 0 0 0;
  background-color: var(--pomegranate);
  color: white;
}*/

form abbr[title] {
  /* get rid of default underline */
  text-decoration: none;
}

/* if not using <strong> around the * for required indicator */
form abbr[title=required] {
  font-weight: bold;
}

/* if field is not required, don't display the <abbr> element */
input:not(.button):not(:required) ~ strong abbr,
select:not(:required) ~ strong abbr,
textarea:not(:required) ~ strong abbr {
  display: none;
}

.row {
  /* font-size: 0 is used so that when using display: inline-block
     for contained elements, there is no space inherent between
     those elements with display set to inline-block;
     Then contained elements must have font-size reset to some
     non-zero value if needed for font or using em */
  margin: 0 auto;
  /*font-size: 0;*/
  /*border: 1px dashed blue;*/
  /*overflow: auto;*/
}

/* used in Billing and Shipping form to indicate same bill/ship address */
div.same_info_checkbox {
  margin: 1rem 0;
  padding: 1rem 0;
  border-bottom: 2px solid #9e9e9e;
}

.input-field-container {
  /*border: 1px solid orange;*/
  position: relative;
  margin: 0 auto;
  font-family: "Roboto", sans-serif;
  margin-top: 2.2rem;
}

.input-range-container {
  /*border: 1px solid orange;*/
  position: relative;
  margin: 0 auto;
  font-family: "Roboto", sans-serif;
  margin-top: 4.2rem;
}

.input-range-container label {
  /*border: 1px solid red;
  width: 100%;*/
  font-size: 1rem;
  color: #9e9e9e;
  color: #888;
  position: absolute;
  top: -2rem;
  left: 0.5rem;
  cursor: pointer;
  transition: all 0.3s ease-out;
}

input[type=range]:focus + label,
input[type=range]:valid + label {
  font-weight: bold;
  top: -2.5rem;
  left: 0;
  font-size: 1.0rem;
  color: #000;
}

.button-container {
  margin-top: 2.1rem;
}

input[type=text], input[type=password],
input[type=email], input[type=date],
input[type=search], input[type=tel],
input[type=time], select,
textarea {
  width: 100%;
  /* get rid of default outline on focus */
  outline: none;
  /* get rid of default border */
  border: 0;
  background-color: #fff;
  border: 1px solid #9e9e9e;
  border-bottom: 2px solid black;
  border-radius: 2px;
  box-shadow: inset 0 2px 4px rgba(125, 125, 125, 0.25);
  height: 3rem;
  padding: 0 0.5rem;
  transition: all 0.3s ease-out;
}

input[type=range] {
  width: 100%;
}

input[type=range]::before {
  position: absolute;
  left: 0;
  top: -1rem;
  color: rgb(0,0,0);
  content: attr(min);
}

input[type=range]::after {
  position: absolute;
  right: 0;
  top: -1rem;
  color: rgb(0,0,0);
  content: attr(max);
}

/* http://danielstern.ca/range.css/#/ */
input[type=range] {
  -webkit-appearance: none;
  width: 100%;
  margin: 10.8px 0;
}
input[type=range]:focus {
  /*outline: none;*/
}
input[type=range]::-webkit-slider-runnable-track {
  width: 100%;
  height: 8.4px;
  cursor: pointer;
  box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
  background: #ddd;
  border-radius: 1.3px;
  border: 0.2px solid #010101;
}
input[type=range]::-webkit-slider-thumb {
  box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
  border: 1px solid #000000;
  height: 30px;
  width: 30px;
  border-radius: 15px;
  background: #ffffff;
  cursor: pointer;
  -webkit-appearance: none;
  margin-top: -11px;
}
input[type=range]:focus::-webkit-slider-runnable-track {
  background: #ddd;
}
input[type=range]::-moz-range-track {
  width: 100%;
  height: 8.4px;
  cursor: pointer;
  box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
  background: #ddd;
  border-radius: 1.3px;
  border: 0.2px solid #010101;
}
input[type=range]::-moz-range-thumb {
  box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
  border: 1px solid #000000;
  height: 30px;
  width: 30px;
  border-radius: 15px;
  background: #ffffff;
  cursor: pointer;
}
input[type=range]::-ms-track {
  width: 100%;
  height: 8.4px;
  cursor: pointer;
  background: transparent;
  border-color: transparent;
  color: transparent;
}
input[type=range]::-ms-fill-lower {
  background: #ddd;
  border: 0.2px solid #010101;
  border-radius: 2.6px;
  box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
}
input[type=range]::-ms-fill-upper {
  background: #ddd;
  border: 0.2px solid #010101;
  border-radius: 2.6px;
  box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
}
input[type=range]::-ms-thumb {
  box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;
  border: 1px solid #000000;
  height: 30px;
  width: 30px;
  border-radius: 15px;
  background: #ffffff;
  cursor: pointer;
  height: 8.4px;
}
input[type=range]:focus::-ms-fill-lower {
  background: #ddd;
}
input[type=range]:focus::-ms-fill-upper {
  background: #ddd;
}

input[type=range].red::-webkit-slider-thumb {
  background: rgba(255,0,0,1);
}
input[type=range].red::-moz-range-thumb {
  background: rgba(255,0,0,1);
}
input[type=range].red::-ms-thumb {
  background: rgba(255,0,0,1);
}

input[type=range].green::-webkit-slider-thumb {
  background: rgba(0,255,0,1);
}
input[type=range].green::-moz-range-thumb {
  background: rgba(0,255,0,1);
}
input[type=range].green::-ms-thumb {
  background: rgba(0,255,0,1);
}

input[type=range].blue::-webkit-slider-thumb {
  background: rgba(0,0,255,1);
}
input[type=range].blue::-moz-range-thumb {
  background: rgba(0,0,255,1);
}
input[type=range].blue::-ms-thumb {
  background: rgba(0,0,255,1);
}

textarea {
  height: 5rem;
  border: 1px solid #9e9e9e;
}

.password-instructions {
  /*border: 1px solid blue;*/
}

.password-instructions ul {
  /*border: 1px solid red;*/
  padding: 0 0 0 1.25rem;
  margin-top: 1rem;
  margin: 1rem 0 0 0;
  font-size: 0.8rem;
  overflow: auto;
}

.password-instructions ul li {
  float: left;
  width: 50%;
  padding-right: 1.5rem;
  /* text-indent can be non-uniform across browsers */
  text-indent: -0.25rem;
}

.forgot-password {
  font-size: 1.0rem;
  position: absolute;
  top: -1.4rem;
  right: 0;
}

/* this is here to provide the "accessibility outline" to the
   input element when in focus for browsers other than Chrome */
input:focus:not(.button):not([type=range]), select:focus, textarea:focus {
/*input:focus:not(.button), select:focus, textarea:focus {*/
  /* get rid of non-focus border so as not to mix the looks */
  /* I find the mix to be not appealing */
  border: 0;
/* however, iPad shows no :focus outline and so the input field is completely
   undefined with regard to border, so I'll keep the border styling; */
  border-bottom: 2px solid #000;
  box-shadow: 0 0 1px 3px rgb(131, 191, 252);
  /*box-shadow: inset 0 3px 6px rgba(131, 191, 252, 0.5),0 0 1px 3px rgb(131, 191, 252);*/
  /* I like this one better */
  /*box-shadow: inset 0 2px 4px rgba(131, 191, 252, 0.5),0 0 1px 3px rgb(131, 191, 252);*/
}

.input-field-container label {
  /*border: 1px solid red;
  width: 100%;*/
  font-size: 1rem;
  color: #9e9e9e;
  color: #888;
  position: absolute;
  top: 0.8rem;
  left: 0.5rem;
  cursor: pointer;
  transition: all 0.3s ease-out;
}

/* this rule is used because of animating the label and showing/hiding
  the colon or other suffix following the label text */
.input-field-container label span.suffix {
  opacity: 0;
}

/* unique left positions for fields with "pickers" */
input[type=date] + label {
  left: 6.8rem;
}
input[type=time] + label {
  left: 4.8rem;
}

/* target labels with these rules that are to always be above input element */
input[name*="address_billing"] + label,
input[name*="address_shipping"] + label {
  font-weight: bold;
  top: -1.4rem;
  left: 0;
  font-size: 1.0rem;
  color: #000;
}

/* This rule is used to make the labels opaque, regardless of :focus, :valid */
/* So far, I've used them for elements with extensive placeholder text. */
input[name*="address_billing"] + label span.suffix,
input[name*="address_shipping"] + label span.suffix {
  opacity: 1;
}

/* not sure if I want to use this feature or quite where to display */
.check {
  position: absolute;
  /* the next top/right pair will place the check
     above the RHS of the input field; */
  top: -1.9rem;
  right: 0.0rem;
  /* the next top/right pair will place the check
     inside the input field on the RHS; */
  /*top: 0;
  right: 0.4rem;*/
  font-size: 1.5em;
  color: rgb(0,220,0);
  text-shadow: 1px 1px 1px #666;
  margin-left: 1.5em;
  opacity: 0;
  /* If check is placed right over the date picker (if that is used),
     .check will prevent the picker from being selected.
     That's why I've put display: none; here for now. */
  /*display: none;*/
  transition: all 0.3s ease-out;
}

/* https://www.youtube.com/watch?v=s7JwxPnYoOw */
.arrowBox {
  display: block;
  /*box-sizing: border-box;*/
  width: 240px;
  height: 60px;
  width: 19em;
  height: 4.5em;
  background-color: rgba(0,0,0,1);
  border-radius: 5px;
  position: absolute;
  z-index: 99;
  top: -68px;
  right: 0;
  /* next 2 rules to center within parent horizontally:
     - left: 50% is 50% of the parent width;
     - translate(50%) is 50% of .arrowBox width; */
  /*
  left: 50%;
  transform: translate(-50%);
  */
  padding: 0.5rem;
  font-family: "Roboto", sans-serif;
  font-size: 0.8em;
  line-height: 1.6em;
  color: rgb(255,255,255);
  text-align: center;
  transition: all 0.3s ease-out;
}

.arrowBox::after {
  display: block;
  /*box-sizing: content-box;*/
  content: "";
  width: 0px;
  height: 0px;
  position: absolute;
  z-index: 98;

  /* downward pointing "arrow" */
  border-top: 10px solid rgb(0,0,0);
  top: 100%;
  /* the following 2 rules will center the "arrow" horizontally in .arrowBox */
  /* the 50% is 50% of the .arrowBox width */
  left: 50%;
  /* move the "arrow" back the distance equal to the border width */
  margin-left: -10px;

  border-right: 10px solid transparent;
  border-bottom: 10px solid transparent;
  border-left: 10px solid transparent;
}

/* initially not displayed; will display on input field focus; */
.arrowBox {
  opacity: 0;
}

/* show .arrowBox when parent input element has focus */
input:not(.button):focus ~ div.arrowBox {
  opacity: 1;
}

.info_icon {
  position: absolute;
  /* the next top/right pair will place the ?
     above the RHS of the input field; */
  /* width 1rem is specified to allow placement of span.info_icon::before,
     and span.info_icon::after elements without guessing/trial-error position */
  width: 1rem;
  top: -1.9rem;
  right: 0.0rem;
  font-size: 1.5em;
  color: rgb(200,0,0);
  font-weight: bold;
  text-shadow: 1px 1px 1px #666;
  opacity: 1;
  cursor: default;
  transition: all 0.3s ease-out;
}

/*
.info_icon:hover .info_icon::after {
  content: "The card security code is a 3 or 4 digit code on either the front or back of your card.";
  position: absolute;
  display: block;

}*/

span.info_icon::before {
  content: attr(title);
  display: block;
  /*box-sizing: border-box;*/
  width: 240px;
  height: 60px;
  /*width: 19em;
  height: 4.5em;*/
  background-color: rgba(0,0,0,1);
  border-radius: 5px;
  position: absolute;
  z-index: 99;
  top: -34px;
  right: 0;
  margin-right: 1.6rem;
  /* next 2 rules to center within parent horizontally:
     - left: 50% is 50% of the parent width;
     - translate(50%) is 50% of .arrowBox width; */
  /*
  left: 50%;
  transform: translate(-50%);
  */
  padding: 0.5rem;
  font-family: "Roboto", sans-serif;
  /* get rid of 2 text treatments from parent */
  font-weight: normal;
  text-shadow: none;

  font-size: 0.8rem;
  line-height: 1.6em;
  color: rgb(255,255,255);
  text-align: center;
  opacity: 0;
  transition: all 0.3s ease-out;
}

span.info_icon::after {
  display: block;
  /*box-sizing: content-box;*/
  content: "";
  width: 0px;
  height: 0px;
  position: absolute;
  z-index: 98;

  /* downward pointing "arrow" */
  border-top: 10px solid transparent;
  /* the following 2 rules will center the "arrow" horizontally in .arrowBox */
  /* the 50% is 50% of the .arrowBox width */
  /*left: 50%;*/
  /* move the "arrow" back the distance equal to the border width */
  /*margin-left: -10px;*/

  border-right: 10px solid transparent;
  border-bottom: 10px solid transparent;

  border-left: 10px solid rgb(0,0,0);
  left: -0.6rem;
  top: 0;
  opacity: 0;
  transition: all 0.3s ease-out;
}

span.info_icon:hover::before, span.info_icon:hover::after {
  opacity: 1;
}

.input-field-container abbr {
  position: absolute;
  top: 0.9rem;
  right: -1rem;
}

/* emulate default pastel yellow background upon valid and required input field value */
/* as this rule is, you need to add the .validate class to the input element
   to have this effect occur; removing the .validate portion of this rule
   will make this effect occur whenever there is valid input; */
input:not(.button):not([type="submit"]):not([type="button"]).validate:valid:required {
  background-color: #faffbd;
}

/* if input value is valid, move or leave the label above
  the input field element */
/* Unfortunate side-effect here is that when an element does not have the
  required attribute set, then it is always valid and the label will be
  moved above the element, eliminating the CSS transition animation. Maybe this
  can be corrected with JS later, i.e., check for blank field and leave label
  inside like the pseudo-placeholder effect I'm trying to achieve. */
/* The converse problem occurs when an input field is left blank (including
  when page first loads), and if I try to use styling using :invalid with either
  or both of the required attribute and a pattern/specific type such as date,
  then the styling is in effect when the page loads and everything is blank.
  So there again, JS can be used later to check for empty input field.
  But maybe ultimately, I'll do something else and leave the damned labels in a
  normal spot and use placeholder text as appropriate! */
input:not(.button):not([type=range]):focus + label,
input:not(.button):not([type=range]):valid + label,
.input-field-container select + label,
.input-field-container textarea + label {
  font-weight: bold;
  top: -1.4rem;
  left: 0;
  font-size: 1.0rem;
  color: #000;
}

/* for input fields with "pickers" that have prefix text */
input[type=search]:focus + label span.prefix,
input[type=search]:valid + label span.prefix,
input[type=date]:focus + label span.prefix,
input[type=date]:valid + label span.prefix,
input[type=time]:focus + label span.prefix,
input[type=time]:valid + label span.prefix {
  /* using display: none; gets these elements out of the layout */
  display: none;
}

/* make .suffix visible when label is used as floating above input */
input:not(.button):focus + label span.suffix,
input:not(.button):valid + label span.suffix,
textarea:focus + label span.suffix,
textarea:valid + label span.suffix {
  opacity: 1;
}

/* this displays the .check span with a check in it */
/* note the use of multiple sibling combinators to
   "hopscotch" to the element I want */
/* not sure if I want to use this feature */
input:not(.button):valid + label + span.check {
  /*opacity: 1;*/
}

/* http://foundation.zurb.com/sites/docs/v/5.5.3/media-queries.html */

// Small screens

/* Define mobile styles */
@media only screen {

}

/* max-width 640px, mobile-only styles, use when QAing mobile issues */
@media only screen and (max-width: 40em) {
  body {
    margin: 0.25rem;
  }
  form {
    width: 300px;
    padding: 1rem 2.0rem 2rem 1.5rem;
  }
  form .form-header {
    padding: 0 0 0.25rem 0;
  }
  .password-instructions ul li {
      float: none;
      width: 100%;
  }
  .button {
    width: 100%;
  }
  form .form-header img {
  max-width: 230px;
  }
}

// Medium screens

/* min-width 641px, medium screens */
@media only screen and (min-width: 40.063em) {

}

/* min-width 641px and max-width 1024px, use when QAing tablet-only issues */
@media only screen and (min-width: 40.063em) and (max-width: 64em) {

}

// Large screens

/* min-width 1025px, large screens */
@media only screen and (min-width: 64.063em) {

}

/* min-width 1025px and max-width 1440px, use when QAing large screen-only issues */
@media only screen and (min-width: 64.063em) and (max-width: 90em) {

}

// XLarge screens

/* min-width 1441px, xlarge screens */
@media only screen and (min-width: 90.063em) {

}

/* min-width 1441px and max-width 1920px, use when QAing xlarge screen-only issues */
@media only screen and (min-width: 90.063em) and (max-width: 120em) {

}

// XXLarge screens

/* min-width 1921px, xxlarge screens */
@media only screen and (min-width: 120.063em) {

}
